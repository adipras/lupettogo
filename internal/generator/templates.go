package generator

// Template files embedded as strings to avoid go:embed module issues

var templateFiles = map[string]string{
	"main.go": `package main

import (
	"log"
	"os"

	"{{.ProjectName}}/internal/config"
	"{{.ProjectName}}/internal/server"
	"github.com/joho/godotenv"
)

func main() {
	// Load environment variables
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found")
	}

	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	// Start server
	srv := server.New(cfg)
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	log.Printf("Starting server on port %s", port)
	if err := srv.Start(":" + port); err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
}`,

	"go.mod": `module {{.ProjectName}}

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/joho/godotenv v1.5.1
    github.com/sirupsen/logrus v1.9.3
    github.com/spf13/viper v1.18.2
    github.com/stretchr/testify v1.8.4
    gorm.io/driver/mysql v1.5.4
    gorm.io/driver/postgres v1.5.6
    gorm.io/gorm v1.25.7
)`,

	".env.example": `# Server Configuration
PORT=8080
GIN_MODE=debug

# Database Configuration
DB_HOST=localhost
{{if eq .DBDriver "mysql"}}DB_PORT=3306{{else}}DB_PORT=5432{{end}}
{{if eq .DBDriver "mysql"}}DB_USER=root{{else}}DB_USER=postgres{{end}}
DB_PASSWORD=password
DB_NAME={{.ProjectName}}_db
DB_DRIVER={{.DBDriver}}

# JWT Configuration
JWT_SECRET=your-super-secret-jwt-key-here
JWT_EXPIRES_IN=24h

# API Configuration
API_VERSION=v1`,

	".gitignore": `# Binaries
*.exe
*.exe~
*.dll
*.so
*.dylib
{{.ProjectName}}

# Test binary
*.test

# Coverage
*.out
coverage.html

# Environment files
.env
.env.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Dependencies
vendor/

# Database
*.db
*.sqlite
*.sqlite3`,

	"README.md": `# {{.ProjectName}}

A production-ready Golang SaaS starter project generated by LupettoGo üê∫.

## Getting Started

### Prerequisites

- Go 1.21 or higher
- PostgreSQL or MySQL database (optional)

### Installation

1. Clone this project (if generated separately)
2. Copy environment variables:
   ` + "`" + `bash
   cp .env.example .env
   ` + "`" + `
3. Edit ` + "`" + `.env` + "`" + ` with your configuration
4. Install dependencies:
   ` + "`" + `bash
   go mod tidy
   ` + "`" + `

### Running the Application

` + "`" + `bash
# Development
go run main.go

# Build binary
go build -o {{.ProjectName}} main.go
./{{.ProjectName}}
` + "`" + `

The server will start on ` + "`" + `http://localhost:8080` + "`" + `

### Available Endpoints

- ` + "`" + `GET /health` + "`" + ` - Health check endpoint
- ` + "`" + `GET /api/v1/example` + "`" + ` - Example API endpoint

## Generated by LupettoGo üê∫

This project was scaffolded using LupettoGo - a CLI tool for creating production-ready Golang SaaS starter projects.

*With the little wolf, no project is too big.*`,

	"Dockerfile": `# Build stage
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Copy go mod files
COPY go.mod go.sum ./
RUN go mod download

# Copy source code
COPY . .

# Build the application
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# Final stage
FROM alpine:latest

RUN apk --no-cache add ca-certificates tzdata
WORKDIR /root/

# Copy the binary from builder stage
COPY --from=builder /app/main .

# Copy .env.example as template
COPY --from=builder /app/.env.example .

EXPOSE 8080

CMD ["./main"]`,

	"Makefile": `# {{.ProjectName}} Makefile

# Variables
BINARY_NAME={{.ProjectName}}
DOCKER_IMAGE={{.ProjectName}}:latest

# Build the application
build:
	go build -o $(BINARY_NAME) main.go

# Run the application
run:
	go run main.go

# Run tests
test:
	go test -v ./...

# Run tests with coverage
test-coverage:
	go test -v -coverprofile=coverage.out ./...
	go tool cover -html=coverage.out -o coverage.html

# Run linter
lint:
	golangci-lint run

# Format code
fmt:
	go fmt ./...

# Tidy dependencies
tidy:
	go mod tidy

# Install dependencies
deps:
	go mod download

# Clean build artifacts
clean:
	rm -f $(BINARY_NAME)
	rm -f coverage.out
	rm -f coverage.html

# Docker build
docker-build:
	docker build -t $(DOCKER_IMAGE) .

# Docker run
docker-run:
	docker run -p 8080:8080 $(DOCKER_IMAGE)

# Development setup
dev-setup:
	go mod tidy
	cp .env.example .env

# Help
help:
	@echo "Available commands:"
	@echo "  build         - Build the application"
	@echo "  run           - Run the application"
	@echo "  test          - Run tests"
	@echo "  test-coverage - Run tests with coverage"
	@echo "  lint          - Run linter"
	@echo "  fmt           - Format code"
	@echo "  tidy          - Tidy dependencies"
	@echo "  clean         - Clean build artifacts"
	@echo "  docker-build  - Build Docker image"
	@echo "  docker-run    - Run Docker container"
	@echo "  dev-setup     - Setup development environment"

.PHONY: build run test test-coverage lint fmt tidy deps clean docker-build docker-run dev-setup help`,
}